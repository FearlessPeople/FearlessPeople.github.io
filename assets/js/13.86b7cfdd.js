(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{453:function(a,t,s){"use strict";s.r(t);var r=s(10),e=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("p"),s("div",{staticClass:"table-of-contents"},[s("ul",[s("li",[s("a",{attrs:{href:"#flink是什么"}},[a._v("Flink是什么?")]),s("ul",[s("li",[s("a",{attrs:{href:"#有界和无界"}},[a._v("有界和无界")])])])]),s("li",[s("a",{attrs:{href:"#flink的架构"}},[a._v("Flink的架构")]),s("ul",[s("li",[s("a",{attrs:{href:"#flink-集群剖析"}},[a._v("Flink 集群剖析")])]),s("li",[s("a",{attrs:{href:"#tasks-和算子链"}},[a._v("Tasks 和算子链")])]),s("li",[s("a",{attrs:{href:"#task-slots-和资源"}},[a._v("Task Slots 和资源")])])])]),s("li",[s("a",{attrs:{href:"#flink-应用程序执行"}},[a._v("Flink 应用程序执行")]),s("ul",[s("li",[s("a",{attrs:{href:"#flink-session-集群"}},[a._v("Flink Session 集群")])]),s("li",[s("a",{attrs:{href:"#flink-job-集群"}},[a._v("Flink Job 集群")])]),s("li",[s("a",{attrs:{href:"#flink-application-集群"}},[a._v("Flink Application 集群")])])])]),s("li",[s("a",{attrs:{href:"#flink的主要特点"}},[a._v("Flink的主要特点")]),s("ul",[s("li",[s("a",{attrs:{href:"#事件驱动-event-driven"}},[a._v("事件驱动(Event-driven)")])]),s("li",[s("a",{attrs:{href:"#基于流的世界观"}},[a._v("基于流的世界观")])]),s("li",[s("a",{attrs:{href:"#分层api"}},[a._v("分层API")])]),s("li",[s("a",{attrs:{href:"#其他特点"}},[a._v("其他特点")])]),s("li",[s("a",{attrs:{href:"#flink-vs-spark-streamting"}},[a._v("Flink VS Spark Streamting")])])])]),s("li",[s("a",{attrs:{href:"#容错机制"}},[a._v("容错机制")])]),s("li",[s("a",{attrs:{href:"#状态管理"}},[a._v("状态管理")])]),s("li",[s("a",{attrs:{href:"#状态一致性"}},[a._v("状态一致性")])]),s("li",[s("a",{attrs:{href:"#应用场景"}},[a._v("应用场景")]),s("ul",[s("li",[s("a",{attrs:{href:"#事件驱动型应用"}},[a._v("事件驱动型应用")])]),s("li",[s("a",{attrs:{href:"#典型的事件驱动型应用实例"}},[a._v("典型的事件驱动型应用实例")])])])]),s("li",[s("a",{attrs:{href:"#数据分析应用"}},[a._v("数据分析应用")]),s("ul",[s("li",[s("a",{attrs:{href:"#什么是数据分析应用"}},[a._v("什么是数据分析应用？")])]),s("li",[s("a",{attrs:{href:"#流式分析应用的优势"}},[a._v("流式分析应用的优势？")])]),s("li",[s("a",{attrs:{href:"#flink-如何支持数据分析类应用"}},[a._v("Flink 如何支持数据分析类应用？")])]),s("li",[s("a",{attrs:{href:"#典型的数据分析应用实例"}},[a._v("典型的数据分析应用实例")])])])]),s("li",[s("a",{attrs:{href:"#数据管道应用"}},[a._v("数据管道应用")]),s("ul",[s("li",[s("a",{attrs:{href:"#什么是数据管道"}},[a._v("什么是数据管道？")])]),s("li",[s("a",{attrs:{href:"#数据管道的优势"}},[a._v("数据管道的优势？")])]),s("li",[s("a",{attrs:{href:"#flink-如何支持数据管道应用"}},[a._v("Flink 如何支持数据管道应用？")])]),s("li",[s("a",{attrs:{href:"#典型的数据管道应用实例"}},[a._v("典型的数据管道应用实例")])])])])])]),s("p"),a._v(" "),s("h2",{attrs:{id:"flink是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#flink是什么"}},[a._v("#")]),a._v(" Flink是什么?")]),a._v(" "),s("p",[a._v("很多人是在2015年才听到Flink这个词的，其实早在2008年，Flink的前身就已经是柏林理工大学的一个研究性项目，在2014年这个项目被Apache孵化器所接受后，Flink迅速成为ASF（Apache Software Foundation）的顶级项目之一")]),a._v(" "),s("p",[s("a",{attrs:{href:"https://flink.apache.org/",target:"_blank",rel:"noopener noreferrer"}},[a._v("Apache Flink "),s("OutboundLink")],1),a._v("是一个"),s("code",[a._v("框架")]),a._v("和"),s("code",[a._v("分布式处理引擎")]),a._v("，用于在"),s("code",[a._v("无边界")]),a._v("和"),s("code",[a._v("有边界")]),a._v("数据流上进行有"),s("code",[a._v("状态")]),a._v("的计算。Flink 能在所有常见集群环境中运行，并能以内存速度和任意规模进行计算。")]),a._v(" "),s("p",[a._v("Flink是一个开源的流处理框架，它具有以下特点。")]),a._v(" "),s("ul",[s("li",[a._v("分布式：Flink程序可以运行在多台机器上。")]),a._v(" "),s("li",[a._v("高性能：处理性能比较高。")]),a._v(" "),s("li",[a._v("高可用：由于Flink程序本身是稳定的，因此它支持高可用性（High Availability，HA）。")]),a._v(" "),s("li",[a._v("准确：Flink可以保证数据处理的准确性。\nFlink主要由Java代码实现，它同时支持实时流处理和批处理。")])]),a._v(" "),s("p",[a._v("对于Flink而言，作为一个流处理框架，批数据只是流数据的一个极限特例而已。此外，Flink还支持迭代计算、内存管理和程序优化，这是它的原生特性。")]),a._v(" "),s("p",[a._v("由下图可知，Flink的功能特性如下。")]),a._v(" "),s("ul",[s("li",[a._v("流式优先：Flink可以连续处理流式数据。")]),a._v(" "),s("li",[a._v("容错：Flink提供有状态的计算，可以记录数据的处理状态，当数据处理失败的时候，能够无缝地从失败中恢复，并保持Exactly-once。")]),a._v(" "),s("li",[a._v("可伸缩：Flink中的一个集群支持上千个节点。")]),a._v(" "),s("li",[a._v("性能：Flink支持高吞吐、低延迟。")])]),a._v(" "),s("p",[s("img",{attrs:{src:"https://tva1.sinaimg.cn/large/008i3skNly1gvab2w29xij61v80u0n0b02.jpg",alt:""}})]),a._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[a._v("在这里解释一下")]),a._v(" "),s("p",[a._v("高吞吐表示单位时间内可以处理的数据量很大，\n低延迟表示数据产生以后可以在很短的时间内对其进行处理\n也就是Flink可以支持快速地处理海量数据。")])]),a._v(" "),s("h3",{attrs:{id:"有界和无界"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#有界和无界"}},[a._v("#")]),a._v(" 有界和无界")]),a._v(" "),s("p",[a._v("任何类型的数据都可以形成一种事件流。信用卡交易、传感器测量、机器日志、网站或移动应用程序上的用户交互记录，所有这些数据都形成一种流。")]),a._v(" "),s("p",[a._v("数据可以被作为 无界 或者 有界 流来处理。")]),a._v(" "),s("p",[s("strong",[a._v("无界流")]),a._v(" 有定义流的开始，但没有定义流的结束。它们会无休止地产生数据。无界流的数据必须持续处理，即数据被摄取后需要立刻处理。我们不能等到所有数据都到达再处理，因为输入是无限的，在任何时候输入都不会完成。处理无界数据通常要求以特定顺序摄取事件，例如事件发生的顺序，以便能够推断结果的完整性。")]),a._v(" "),s("p",[s("strong",[a._v("有界流")]),a._v(" 有定义流的开始，也有定义流的结束。有界流可以在摄取所有数据后再进行计算。有界流所有数据可以被排序，所以并不需要有序摄取。有界流处理通常被称为批处理")]),a._v(" "),s("p",[s("img",{attrs:{src:"/img/BigData/Flink/bounded_unbounded.png",alt:"bounded_unbounded"}})]),a._v(" "),s("h2",{attrs:{id:"flink的架构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#flink的架构"}},[a._v("#")]),a._v(" Flink的架构")]),a._v(" "),s("p",[a._v("Flink 是一个分布式系统，需要有效分配和管理计算资源才能执行流应用程序。它集成了所有常见的集群资源管理器，例如Hadoop YARN，但也可以设置作为独立集群甚至库运行。")]),a._v(" "),s("h3",{attrs:{id:"flink-集群剖析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#flink-集群剖析"}},[a._v("#")]),a._v(" Flink 集群剖析")]),a._v(" "),s("p",[a._v("Flink 运行时由两种类型的进程组成：一个 "),s("code",[a._v("JobManager")]),a._v(" 和一个或者多个 "),s("code",[a._v("TaskManager")]),a._v("。\n"),s("img",{attrs:{src:"https://tva1.sinaimg.cn/large/008i3skNly1gva9xnuh26j60ys0p2wil02.jpg",alt:""}})]),a._v(" "),s("p",[a._v("Client 不是运行时和程序执行的一部分，而是用于准备数据流并将其发送给 JobManager。之后，客户端可以断开连接（分离模式），或保持连接来接收进程报告（附加模式）。客户端可以作为触发执行 Java/Scala 程序的一部分运行，也可以在命令行进程./bin/flink run ...中运行。")]),a._v(" "),s("p",[a._v("可以通过多种方式启动 JobManager 和 TaskManager：直接在机器上作为standalone 集群启动、在容器中启动、或者通过YARN等资源框架管理并启动。TaskManager 连接到 JobManagers，宣布自己可用，并被分配工作。")]),a._v(" "),s("h4",{attrs:{id:"jobmanager"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jobmanager"}},[a._v("#")]),a._v(" JobManager")]),a._v(" "),s("p",[a._v("JobManager 具有许多与协调 Flink 应用程序的分布式执行有关的职责：它决定何时调度下一个 task（或一组 task）、对完成的 task 或执行失败做出反应、协调 checkpoint、并且协调从失败中恢复等等。这个进程由三个不同的组件组成：")]),a._v(" "),s("p",[s("strong",[a._v("ResourceManager")])]),a._v(" "),s("p",[a._v("ResourceManager 负责 Flink 集群中的资源提供、回收、分配 - 它管理 task slots，这是 Flink 集群中资源调度的单位（请参考TaskManagers）。Flink 为不同的环境和资源提供者（例如 YARN、Kubernetes 和 standalone 部署）实现了对应的 ResourceManager。在 standalone 设置中，ResourceManager 只能分配可用 TaskManager 的 slots，而不能自行启动新的 TaskManager。")]),a._v(" "),s("p",[s("strong",[a._v("Dispatcher")])]),a._v(" "),s("p",[a._v("Dispatcher 提供了一个 REST 接口，用来提交 Flink 应用程序执行，并为每个提交的作业启动一个新的 JobMaster。它还运行 Flink WebUI 用来提供作业执行信息。")]),a._v(" "),s("p",[s("strong",[a._v("JobMaster")])]),a._v(" "),s("p",[a._v("JobMaster 负责管理单个JobGraph的执行。Flink 集群中可以同时运行多个作业，每个作业都有自己的 JobMaster。")]),a._v(" "),s("p",[a._v("始终至少有一个 JobManager。高可用（HA）设置中可能有多个 JobManager，其中一个始终是 leader，其他的则是 standby（请参考\n"),s("a",{attrs:{href:"https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/deployment/ha/overview/",target:"_blank",rel:"noopener noreferrer"}},[a._v("高可用（HA）"),s("OutboundLink")],1),a._v("）")]),a._v(" "),s("h4",{attrs:{id:"taskmanagers"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#taskmanagers"}},[a._v("#")]),a._v(" TaskManagers")]),a._v(" "),s("p",[a._v("TaskManager（也称为 worker）执行作业流的 task，并且缓存和交换数据流。")]),a._v(" "),s("p",[a._v("必须始终至少有一个 TaskManager。在 TaskManager 中资源调度的最小单位是 task slot。TaskManager 中 task slot 的数量表示并发处理 task 的数量。请注意一个 task slot 中可以执行多个算子（请参考"),s("a",{attrs:{href:"https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/concepts/flink-architecture/#tasks-and-operator-chains",target:"_blank",rel:"noopener noreferrer"}},[a._v("Tasks 和算子链"),s("OutboundLink")],1),a._v("）。")]),a._v(" "),s("h3",{attrs:{id:"tasks-和算子链"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tasks-和算子链"}},[a._v("#")]),a._v(" Tasks 和算子链")]),a._v(" "),s("p",[a._v("对于分布式执行，Flink 将算子的 subtasks 链接成 tasks。每个 task 由一个线程执行。将算子链接成 task 是个有用的优化：它减少线程间切换、缓冲的开销，并且减少延迟的同时增加整体吞吐量。链行为是可以配置的；请参考链文档以获取详细信息。")]),a._v(" "),s("p",[a._v("下图中样例数据流用 5 个 subtask 执行，因此有 5 个并行线程。\n"),s("img",{attrs:{src:"https://tva1.sinaimg.cn/large/008i3skNly1gvaa3hgiuzj613o0raq7602.jpg",alt:""}})]),a._v(" "),s("h3",{attrs:{id:"task-slots-和资源"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#task-slots-和资源"}},[a._v("#")]),a._v(" Task Slots 和资源")]),a._v(" "),s("p",[a._v("每个 worker（TaskManager）都是一个 JVM 进程，可以在单独的线程中执行一个或多个 subtask。为了控制一个 TaskManager 中接受多少个 task，就有了所谓的 task slots（至少一个）。")]),a._v(" "),s("p",[a._v("每个 task slot 代表 TaskManager 中资源的固定子集。例如，具有 3 个 slot 的 TaskManager，会将其托管内存 1/3 用于每个 slot。分配资源意味着 subtask 不会与其他作业的 subtask 竞争托管内存，而是具有一定数量的保留托管内存。注意此处没有 CPU 隔离；当前 slot 仅分离 task 的托管内存。")]),a._v(" "),s("p",[a._v("通过调整 task slot 的数量，用户可以定义 subtask 如何互相隔离。每个 TaskManager 有一个 slot，这意味着每个 task 组都在单独的 JVM 中运行（例如，可以在单独的容器中启动）。具有多个 slot 意味着更多 subtask 共享同一 JVM。同一 JVM 中的 task 共享 TCP 连接（通过多路复用）和心跳信息。它们还可以共享数据集和数据结构，从而减少了每个 task 的开销。")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://tva1.sinaimg.cn/large/008i3skNly1gvaa4cea8wj613s0d840q02.jpg",alt:""}})]),a._v(" "),s("p",[a._v("默认情况下，Flink 允许 subtask 共享 slot，即便它们是不同的 task 的 subtask，只要是来自于同一作业即可。结果就是一个 slot 可以持有整个作业管道。允许 slot 共享有两个主要优点：")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("Flink 集群所需的 task slot 和作业中使用的最大并行度恰好一样。无需计算程序总共包含多少个 task（具有不同并行度）。")])]),a._v(" "),s("li",[s("p",[a._v("容易获得更好的资源利用。如果没有 slot 共享，非密集 subtask（source/map()）将阻塞和密集型 subtask（window） 一样多的资源。通过 slot 共享，我们示例中的基本并行度从 2 增加到 6，可以充分利用分配的资源，同时确保繁重的 subtask 在 TaskManager 之间公平分配。")])])]),a._v(" "),s("p",[s("img",{attrs:{src:"https://tva1.sinaimg.cn/large/008i3skNly1gvaa50pabwj61340imaem02.jpg",alt:""}})]),a._v(" "),s("h2",{attrs:{id:"flink-应用程序执行"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#flink-应用程序执行"}},[a._v("#")]),a._v(" Flink 应用程序执行")]),a._v(" "),s("p",[a._v("Flink 应用程序 是从其 main() 方法产生的一个或多个 Flink 作业的任何用户程序。这些作业的执行可以在本地 JVM（LocalEnvironment）中进行，或具有多台机器的集群的远程设置（RemoteEnvironment）中进行。对于每个程序，ExecutionEnvironment 提供了一些方法来控制作业执行（例如设置并行度）并与外界交互（请参考 "),s("a",{attrs:{href:"https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/dev/datastream/overview/#anatomy-of-a-flink-program",target:"_blank",rel:"noopener noreferrer"}},[a._v("Flink 程序剖析"),s("OutboundLink")],1),a._v(" ）。")]),a._v(" "),s("p",[a._v("Flink 应用程序的作业可以被提交到长期运行的 "),s("a",{attrs:{href:"https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/concepts/glossary/#flink-session-cluster",target:"_blank",rel:"noopener noreferrer"}},[a._v("Flink Session 集群"),s("OutboundLink")],1),a._v("、专用的 "),s("a",{attrs:{href:"https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/concepts/glossary/#flink-job-cluster",target:"_blank",rel:"noopener noreferrer"}},[a._v("Flink Job 集群"),s("OutboundLink")],1),a._v(" 或 "),s("a",{attrs:{href:"https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/concepts/glossary/#flink-application-cluster",target:"_blank",rel:"noopener noreferrer"}},[a._v("Flink Application 集群"),s("OutboundLink")],1),a._v("。这些选项之间的差异主要与集群的生命周期和资源隔离保证有关。")]),a._v(" "),s("h3",{attrs:{id:"flink-session-集群"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#flink-session-集群"}},[a._v("#")]),a._v(" Flink Session 集群")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("集群生命周期：在 Flink Session 集群中，客户端连接到一个预先存在的、长期运行的集群，该集群可以接受多个作业提交。即使所有作业完成后，集群（和 JobManager）仍将继续运行直到手动停止 session 为止。因此，Flink Session 集群的寿命不受任何 Flink 作业寿命的约束。")])]),a._v(" "),s("li",[s("p",[a._v("资源隔离：TaskManager slot 由 ResourceManager 在提交作业时分配，并在作业完成时释放。由于所有作业都共享同一集群，因此在集群资源方面存在一些竞争 — 例如提交工作阶段的网络带宽。此共享设置的局限性在于，如果 TaskManager 崩溃，则在此 TaskManager 上运行 task 的所有作业都将失败；类似的，如果 JobManager 上发生一些致命错误，它将影响集群中正在运行的所有作业。")])]),a._v(" "),s("li",[s("p",[a._v("其他注意事项：拥有一个预先存在的集群可以节省大量时间申请资源和启动 TaskManager。有种场景很重要，作业执行时间短并且启动时间长会对端到端的用户体验产生负面的影响 — 就像对简短查询的交互式分析一样，希望作业可以使用现有资源快速执行计算。")])])]),a._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[a._v("提示")]),a._v(" "),s("p",[a._v("以前，Flink Session 集群也被称为 session 模式下的 Flink 集群。")])]),a._v(" "),s("h3",{attrs:{id:"flink-job-集群"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#flink-job-集群"}},[a._v("#")]),a._v(" Flink Job 集群")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("集群生命周期：在 Flink Job 集群中，可用的集群管理器（例如 YARN）用于为每个提交的作业启动一个集群，并且该集群仅可用于该作业。在这里，客户端首先从集群管理器请求资源启动 JobManager，然后将作业提交给在这个进程中运行的 Dispatcher。然后根据作业的资源请求惰性的分配 TaskManager。一旦作业完成，Flink Job 集群将被拆除。")])]),a._v(" "),s("li",[s("p",[a._v("资源隔离：JobManager 中的致命错误仅影响在 Flink Job 集群中运行的一个作业。")])]),a._v(" "),s("li",[s("p",[a._v("其他注意事项：由于 ResourceManager 必须应用并等待外部资源管理组件来启动 TaskManager 进程和分配资源，因此 Flink Job 集群更适合长期运行、具有高稳定性要求且对较长的启动时间不敏感的大型作业。")])])]),a._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[a._v("提示")]),a._v(" "),s("p",[a._v("以前，Flink Job 集群也被称为 job (or per-job) 模式下的 Flink 集群。")]),a._v(" "),s("p",[a._v("Kubernetes 不支持 Flink Job 集群。 请参考 "),s("a",{attrs:{href:"https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/deployment/resource-providers/standalone/kubernetes/#per-job-cluster-mode",target:"_blank",rel:"noopener noreferrer"}},[a._v("Standalone Kubernetes"),s("OutboundLink")],1),a._v(" 和 "),s("a",{attrs:{href:"https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/deployment/resource-providers/native_kubernetes/#per-job-cluster-mode",target:"_blank",rel:"noopener noreferrer"}},[a._v("Native Kubernetes"),s("OutboundLink")],1),a._v("。")])]),a._v(" "),s("h3",{attrs:{id:"flink-application-集群"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#flink-application-集群"}},[a._v("#")]),a._v(" Flink Application 集群")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("集群生命周期：Flink Application 集群是专用的 Flink 集群，仅从 Flink 应用程序执行作业，并且 main()方法在集群上而不是客户端上运行。提交作业是一个单步骤过程：无需先启动 Flink 集群，然后将作业提交到现有的 session 集群；相反，将应用程序逻辑和依赖打包成一个可执行的作业 JAR 中，并且集群入口（ApplicationClusterEntryPoint）负责调用 main()方法来提取 JobGraph。例如，这允许你像在 Kubernetes 上部署任何其他应用程序一样部署 Flink 应用程序。因此，Flink Application 集群的寿命与 Flink 应用程序的寿命有关。")])]),a._v(" "),s("li",[s("p",[a._v("资源隔离：在 Flink Application 集群中，ResourceManager 和 Dispatcher 作用于单个的 Flink 应用程序，相比于 Flink Session 集群，它提供了更好的隔离。")])])]),a._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[a._v("提示")]),a._v(" "),s("p",[a._v("Flink Job 集群可以看做是 Flink Application 集群”客户端运行“的替代方案。")])]),a._v(" "),s("h2",{attrs:{id:"flink的主要特点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#flink的主要特点"}},[a._v("#")]),a._v(" Flink的主要特点")]),a._v(" "),s("h3",{attrs:{id:"事件驱动-event-driven"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事件驱动-event-driven"}},[a._v("#")]),a._v(" 事件驱动(Event-driven)")]),a._v(" "),s("h3",{attrs:{id:"基于流的世界观"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基于流的世界观"}},[a._v("#")]),a._v(" 基于流的世界观")]),a._v(" "),s("h3",{attrs:{id:"分层api"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分层api"}},[a._v("#")]),a._v(" 分层API")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://tva1.sinaimg.cn/large/008i3skNly1gv5pf2i23uj60r60g43zy02.jpg",alt:""}})]),a._v(" "),s("h3",{attrs:{id:"其他特点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#其他特点"}},[a._v("#")]),a._v(" 其他特点")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://tva1.sinaimg.cn/large/008i3skNly1gv5phbdrjmj60yo0l0gnj02.jpg",alt:""}})]),a._v(" "),s("h3",{attrs:{id:"flink-vs-spark-streamting"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#flink-vs-spark-streamting"}},[a._v("#")]),a._v(" Flink VS Spark Streamting")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://tva1.sinaimg.cn/large/008i3skNly1gv5piitf2xj60ro0is75u02.jpg",alt:""}})]),a._v(" "),s("p",[s("img",{attrs:{src:"https://tva1.sinaimg.cn/large/008i3skNly1gv5pjgzci4j60x40hcjsw02.jpg",alt:""}})]),a._v(" "),s("h2",{attrs:{id:"容错机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#容错机制"}},[a._v("#")]),a._v(" 容错机制")]),a._v(" "),s("h2",{attrs:{id:"状态管理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#状态管理"}},[a._v("#")]),a._v(" 状态管理")]),a._v(" "),s("h2",{attrs:{id:"状态一致性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#状态一致性"}},[a._v("#")]),a._v(" 状态一致性")]),a._v(" "),s("h2",{attrs:{id:"应用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[a._v("#")]),a._v(" 应用场景")]),a._v(" "),s("p",[a._v("Apache Flink 功能强大，支持开发和运行多种不同种类的应用程序。它的主要特性包括：批流一体化、精密的状态管理、事件时间支持以及精确一次的状态一致性保障等。Flink 不仅可以运行在包括 YARN、 Mesos、Kubernetes 在内的多种资源管理框架上，还支持在裸机集群上独立部署。在启用高可用选项的情况下，它不存在单点失效问题。事实证明，Flink 已经可以扩展到数千核心，其状态可以达到 TB 级别，且仍能保持高吞吐、低延迟的特性。世界各地有很多要求严苛的流处理应用都运行在 Flink 之上。")]),a._v(" "),s("p",[a._v("接下来我们将介绍 Flink 常见的几类应用并给出相关实例链接。")]),a._v(" "),s("ul",[s("li",[s("p",[s("a",{attrs:{href:"http://flink.apache.org/zh/usecases.html#eventDrivenApps",target:"_blank",rel:"noopener noreferrer"}},[a._v("事件驱动型应用"),s("OutboundLink")],1)])]),a._v(" "),s("li",[s("p",[s("a",{attrs:{href:"http://flink.apache.org/zh/usecases.html#analytics",target:"_blank",rel:"noopener noreferrer"}},[a._v("数据分析应用"),s("OutboundLink")],1)])]),a._v(" "),s("li",[s("p",[s("a",{attrs:{href:"http://flink.apache.org/zh/usecases.html#pipelines",target:"_blank",rel:"noopener noreferrer"}},[a._v("数据管道应用"),s("OutboundLink")],1)])]),a._v(" "),s("li",[s("p",[a._v("实时ETL：集成流计算现有的诸多数据通道和SQL灵活的加工能力，对流式数据进行实时清洗、归并和结构化处理；同时，对离线数仓进行有效的补充和优化，并为数据实时传输提供可计算通道。")])]),a._v(" "),s("li",[s("p",[a._v("实时报表：实时化采集、加工流式数据存储；实时监控和展现业务、客户各类指标，让数据化运营实时化。")])]),a._v(" "),s("li",[s("p",[a._v("监控预警：对系统和用户行为进行实时检测和分析，以便及时发现危险行为。")])]),a._v(" "),s("li",[s("p",[a._v("在线系统：实时计算各类数据指标，并利用实时结果及时调整在线系统的相关策略，在各类内容投放、无线智能推送领域有大量的应用。")])])]),a._v(" "),s("h3",{attrs:{id:"事件驱动型应用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事件驱动型应用"}},[a._v("#")]),a._v(" 事件驱动型应用")]),a._v(" "),s("p",[a._v("什么是事件驱动型应用？\n事件驱动型应用是一类具有状态的应用，它从一个或多个事件流提取数据，并根据到来的事件触发计算、状态更新或其他外部动作。")]),a._v(" "),s("p",[a._v("事件驱动型应用是在计算存储分离的传统应用基础上进化而来。在传统架构中，应用需要读写远程事务型数据库。")]),a._v(" "),s("p",[a._v("相反，事件驱动型应用是基于状态化流处理来完成。在该设计中，数据和计算不会分离，应用只需访问本地（内存或磁盘）即可获取数据。系统容错性的实现依赖于定期向远程持久化存储写入 checkpoint。下图描述了传统应用和事件驱动型应用架构的区别。")]),a._v(" "),s("p",[s("strong",[a._v("什么是事件驱动型应用？")]),a._v("\n事件驱动型应用是一类具有状态的应用，它从一个或多个事件流提取数据，并根据到来的事件触发计算、状态更新或其他外部动作。")]),a._v(" "),s("p",[a._v("事件驱动型应用是在计算存储分离的传统应用基础上进化而来。在传统架构中，应用需要读写远程事务型数据库。")]),a._v(" "),s("p",[a._v("相反，事件驱动型应用是基于状态化流处理来完成。在该设计中，数据和计算不会分离，应用只需访问本地（内存或磁盘）即可获取数据。系统容错性的实现依赖于定期向远程持久化存储写入 checkpoint。下图描述了传统应用和事件驱动型应用架构的区别。\n"),s("img",{attrs:{src:"https://tva1.sinaimg.cn/large/008i3skNly1gvaggibwszj612o0d0gn402.jpg",alt:""}})]),a._v(" "),s("p",[s("strong",[a._v("事件驱动型应用的优势？")]),a._v("\n事件驱动型应用无须查询远程数据库，本地数据访问使得它具有更高的吞吐和更低的延迟。而由于定期向远程持久化存储的 checkpoint 工作可以异步、增量式完成，因此对于正常事件处理的影响甚微。事件驱动型应用的优势不仅限于本地数据访问。传统分层架构下，通常多个应用会共享同一个数据库，因而任何对数据库自身的更改（例如：由应用更新或服务扩容导致数据布局发生改变）都需要谨慎协调。反观事件驱动型应用，由于只需考虑自身数据，因此在更改数据表示或服务扩容时所需的协调工作将大大减少。")]),a._v(" "),s("p",[s("strong",[a._v("Flink 如何支持事件驱动型应用？")]),a._v("\n事件驱动型应用会受制于底层流处理系统对时间和状态的把控能力，Flink 诸多优秀特质都是围绕这些方面来设计的。它提供了一系列丰富的状态操作原语，允许以精确一次的一致性语义合并海量规模（TB 级别）的状态数据。此外，Flink 还支持事件时间和自由度极高的定制化窗口逻辑，而且它内置的 ProcessFunction 支持细粒度时间控制，方便实现一些高级业务逻辑。同时，Flink 还拥有一个复杂事件处理（CEP）类库，可以用来检测数据流中的模式。")]),a._v(" "),s("p",[a._v("Flink 中针对事件驱动应用的明星特性当属 savepoint。Savepoint 是一个一致性的状态映像，它可以用来初始化任意状态兼容的应用。在完成一次 savepoint 后，即可放心对应用升级或扩容，还可以启动多个版本的应用来完成 A/B 测试。")]),a._v(" "),s("h3",{attrs:{id:"典型的事件驱动型应用实例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#典型的事件驱动型应用实例"}},[a._v("#")]),a._v(" 典型的事件驱动型应用实例")]),a._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://sf-2017.flink-forward.org/kb_sessions/streaming-models-how-ing-adds-models-at-runtime-to-catch-fraudsters/",target:"_blank",rel:"noopener noreferrer"}},[a._v("反欺诈"),s("OutboundLink")],1)]),a._v(" "),s("li",[s("a",{attrs:{href:"https://sf-2017.flink-forward.org/kb_sessions/building-a-real-time-anomaly-detection-system-with-flink-mux/",target:"_blank",rel:"noopener noreferrer"}},[a._v("异常检测"),s("OutboundLink")],1)]),a._v(" "),s("li",[s("a",{attrs:{href:"https://sf-2017.flink-forward.org/kb_sessions/dynamically-configured-stream-processing-using-flink-kafka/",target:"_blank",rel:"noopener noreferrer"}},[a._v("基于规则的报警"),s("OutboundLink")],1)]),a._v(" "),s("li",[s("a",{attrs:{href:"https://jobs.zalando.com/tech/blog/complex-event-generation-for-business-process-monitoring-using-apache-flink/",target:"_blank",rel:"noopener noreferrer"}},[a._v("业务流程监控"),s("OutboundLink")],1)]),a._v(" "),s("li",[s("a",{attrs:{href:"https://berlin-2017.flink-forward.org/kb_sessions/drivetribes-kappa-architecture-with-apache-flink/",target:"_blank",rel:"noopener noreferrer"}},[a._v("（社交网络）Web 应用"),s("OutboundLink")],1)])]),a._v(" "),s("h2",{attrs:{id:"数据分析应用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据分析应用"}},[a._v("#")]),a._v(" 数据分析应用")]),a._v(" "),s("h3",{attrs:{id:"什么是数据分析应用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是数据分析应用"}},[a._v("#")]),a._v(" 什么是数据分析应用？")]),a._v(" "),s("p",[a._v("数据分析任务需要从原始数据中提取有价值的信息和指标。传统的分析方式通常是利用批查询，或将事件记录下来并基于此有限数据集构建应用来完成。为了得到最新数据的分析结果，必须先将它们加入分析数据集并重新执行查询或运行应用，随后将结果写入存储系统或生成报告。")]),a._v(" "),s("p",[a._v("借助一些先进的流处理引擎，还可以实时地进行数据分析。和传统模式下读取有限数据集不同，流式查询或应用会接入实时事件流，并随着事件消费持续产生和更新结果。这些结果数据可能会写入外部数据库系统或以内部状态的形式维护。仪表展示应用可以相应地从外部数据库读取数据或直接查询应用的内部状态。")]),a._v(" "),s("p",[a._v("如下图所示，Apache Flink 同时支持流式及批量分析应用。")]),a._v(" "),s("p",[s("img",{attrs:{src:"http://flink.apache.org/img/usecases-analytics.png",alt:"img"}})]),a._v(" "),s("h3",{attrs:{id:"流式分析应用的优势"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#流式分析应用的优势"}},[a._v("#")]),a._v(" 流式分析应用的优势？")]),a._v(" "),s("p",[a._v("和批量分析相比，由于流式分析省掉了周期性的数据导入和查询过程，因此从事件中获取指标的延迟更低。不仅如此，批量查询必须处理那些由定期导入和输入有界性导致的人工数据边界，而流式查询则无须考虑该问题。")]),a._v(" "),s("p",[a._v("另一方面，流式分析会简化应用抽象。批量查询的流水线通常由多个独立部件组成，需要周期性地调度提取数据和执行查询。如此复杂的流水线操作起来并不容易，一旦某个组件出错将会影响流水线的后续步骤。而流式分析应用整体运行在 Flink 之类的高端流处理系统之上，涵盖了从数据接入到连续结果计算的所有步骤，因此可以依赖底层引擎提供的故障恢复机制。")]),a._v(" "),s("h3",{attrs:{id:"flink-如何支持数据分析类应用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#flink-如何支持数据分析类应用"}},[a._v("#")]),a._v(" Flink 如何支持数据分析类应用？")]),a._v(" "),s("p",[a._v("Flink 为持续流式分析和批量分析都提供了良好的支持。具体而言，它内置了一个符合 ANSI 标准的 SQL 接口，将批、流查询的语义统一起来。无论是在记录事件的静态数据集上还是实时事件流上，相同 SQL 查询都会得到一致的结果。同时 Flink 还支持丰富的用户自定义函数，允许在 SQL 中执行定制化代码。如果还需进一步定制逻辑，可以利用 Flink DataStream API 和 DataSet API 进行更低层次的控制。此外，Flink 的 Gelly 库为基于批量数据集的大规模高性能图分析提供了算法和构建模块支持。")]),a._v(" "),s("h3",{attrs:{id:"典型的数据分析应用实例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#典型的数据分析应用实例"}},[a._v("#")]),a._v(" 典型的数据分析应用实例")]),a._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"http://2016.flink-forward.org/kb_sessions/a-brief-history-of-time-with-apache-flink-real-time-monitoring-and-analysis-with-flink-kafka-hb/",target:"_blank",rel:"noopener noreferrer"}},[a._v("电信网络质量监控"),s("OutboundLink")],1)]),a._v(" "),s("li",[a._v("移动应用中的"),s("a",{attrs:{href:"https://techblog.king.com/rbea-scalable-real-time-analytics-king/",target:"_blank",rel:"noopener noreferrer"}},[a._v("产品更新及实验评估分析"),s("OutboundLink")],1)]),a._v(" "),s("li",[a._v("消费者技术中的"),s("a",{attrs:{href:"https://eng.uber.com/athenax/",target:"_blank",rel:"noopener noreferrer"}},[a._v("实时数据即席分析"),s("OutboundLink")],1)]),a._v(" "),s("li",[a._v("大规模图分析")])]),a._v(" "),s("h2",{attrs:{id:"数据管道应用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据管道应用"}},[a._v("#")]),a._v(" 数据管道应用")]),a._v(" "),s("h3",{attrs:{id:"什么是数据管道"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是数据管道"}},[a._v("#")]),a._v(" 什么是数据管道？")]),a._v(" "),s("p",[a._v("提取-转换-加载（ETL）是一种在存储系统之间进行数据转换和迁移的常用方法。ETL 作业通常会周期性地触发，将数据从事务型数据库拷贝到分析型数据库或数据仓库。")]),a._v(" "),s("p",[a._v("数据管道和 ETL 作业的用途相似，都可以转换、丰富数据，并将其从某个存储系统移动到另一个。但数据管道是以持续流模式运行，而非周期性触发。因此它支持从一个不断生成数据的源头读取记录，并将它们以低延迟移动到终点。例如：数据管道可以用来监控文件系统目录中的新文件，并将其数据写入事件日志；另一个应用可能会将事件流物化到数据库或增量构建和优化查询索引。")]),a._v(" "),s("p",[a._v("下图描述了周期性 ETL 作业和持续数据管道的差异。")]),a._v(" "),s("p",[s("img",{attrs:{src:"http://flink.apache.org/img/usecases-datapipelines.png",alt:"img"}})]),a._v(" "),s("h3",{attrs:{id:"数据管道的优势"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据管道的优势"}},[a._v("#")]),a._v(" 数据管道的优势？")]),a._v(" "),s("p",[a._v("和周期性 ETL 作业相比，持续数据管道可以明显降低将数据移动到目的端的延迟。此外，由于它能够持续消费和发送数据，因此用途更广，支持用例更多。")]),a._v(" "),s("h3",{attrs:{id:"flink-如何支持数据管道应用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#flink-如何支持数据管道应用"}},[a._v("#")]),a._v(" Flink 如何支持数据管道应用？")]),a._v(" "),s("p",[a._v("很多常见的数据转换和增强操作可以利用 Flink 的 SQL 接口（或 Table API）及用户自定义函数解决。如果数据管道有更高级的需求，可以选择更通用的 DataStream API 来实现。Flink 为多种数据存储系统（如：Kafka、Kinesis、Elasticsearch、JDBC数据库系统等）内置了连接器。同时它还提供了文件系统的连续型数据源及数据汇，可用来监控目录变化和以时间分区的方式写入文件。")]),a._v(" "),s("h3",{attrs:{id:"典型的数据管道应用实例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#典型的数据管道应用实例"}},[a._v("#")]),a._v(" 典型的数据管道应用实例")]),a._v(" "),s("ul",[s("li",[a._v("电子商务中的"),s("a",{attrs:{href:"https://ververica.com/blog/blink-flink-alibaba-search",target:"_blank",rel:"noopener noreferrer"}},[a._v("实时查询索引构建"),s("OutboundLink")],1)]),a._v(" "),s("li",[a._v("电子商务中的"),s("a",{attrs:{href:"https://jobs.zalando.com/tech/blog/apache-showdown-flink-vs.-spark/",target:"_blank",rel:"noopener noreferrer"}},[a._v("持续 ETL"),s("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=e.exports}}]);
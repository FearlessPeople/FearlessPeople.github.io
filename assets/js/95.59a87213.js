(window.webpackJsonp=window.webpackJsonp||[]).push([[95],{541:function(a,v,r){"use strict";r.r(v);var t=r(10),_=Object(t.a)({},(function(){var a=this,v=a.$createElement,r=a._self._c||v;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h2",{attrs:{id:"运行时数据区"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#运行时数据区"}},[a._v("#")]),a._v(" 运行时数据区")]),a._v(" "),r("p",[a._v("Java虚拟机在运行Java程序时，会将它所管理的内存划分为若干个内存区域。这些数据区域有各自的用途、以及创建和销毁时间。有的随着虚拟机启动而启动，有的区域则依赖java线程的启动和结束来建立和销毁。\n"),r("strong",[a._v("Java虚拟机运行时数据区图如下（来自深入理解Java虚拟机：jvm的高级特性和实践）：")]),a._v(" "),r("img",{attrs:{src:"/img/Java/JVM/006tNbRwgy1fvmt0vur8jj30qs0mkq84.jpg",alt:"img"}}),a._v("\n以下对运行时数据区的各个区域做相应的解释：")]),a._v(" "),r("h3",{attrs:{id:"程序计数器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#程序计数器"}},[a._v("#")]),a._v(" 程序计数器")]),a._v(" "),r("p",[a._v("程序计数器是一个较小的内存空间，可以把它看做当前线程执行的字节码时的行号指示器。字节码解释器的工作就是通过不断改变这个计数器来选择下一条需要执行的字节码指令、分支、循环等功能。\n由于java的多线程是通过轮流切换线程分配处理器执行时间的方式来实现的，所以，"),r("strong",[a._v("在任何一个时间点，一个处理器只会执行一条线程中的指令。因此，为了能保证线程切换后能恢复到正确的位置，每条线程都需要有一个独立的程序计数器。各条线程计数器之间互不影响，独立存储。我们称这类内存区域为“线程私有”的内存。")]),a._v("\n如果线程正在执行的是一个java方法，计数器记录的是虚拟机正在执行的字节码指令地址。\n如果线程正在执行的是一个Native方法，这个计数器值则为空。\n此内存区域是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError的情况的区域\n"),r("strong",[a._v("总结：")])]),a._v(" "),r("ol",[r("li",[a._v("程序计数器是一个较小的内存空间")]),a._v(" "),r("li",[a._v("每条线程都需要有一个独立的程序计数器")]),a._v(" "),r("li",[a._v("程序计数器就是一个（当前线程执行的字节码时的行号指示器）")]),a._v(" "),r("li",[a._v("不会出现OutOfMemoryError的情况")])]),a._v(" "),r("h3",{attrs:{id:"java虚拟机栈"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java虚拟机栈"}},[a._v("#")]),a._v(" Java虚拟机栈")]),a._v(" "),r("p",[a._v("与程序计数器一样，虚拟机栈也是线程私有的，它的生命周期和线程相同。虚拟机栈描述的是java方法执行的内存模型：每个java方法在执行时都会创建一个栈帧（stack frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈出栈的过程。\n"),r("strong",[a._v("总结：")])]),a._v(" "),r("ol",[r("li",[a._v("虚拟机栈描述的是java方法执行时的内存模型")]),a._v(" "),r("li",[a._v("会抛出OutOfMemoryError和StackOverflowError异常")])]),a._v(" "),r("h3",{attrs:{id:"本地方法栈"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#本地方法栈"}},[a._v("#")]),a._v(" 本地方法栈")]),a._v(" "),r("p",[a._v("本地方法栈和虚拟机栈所发挥的作用是非常相似的，只不过虚拟机栈是为java虚拟机执行java方法（字节码）而服务，而本地方法栈则是为了虚拟机中使用到的Native方法服务。\n在虚拟机规范中没有明确规定本地方法栈使用的语言、数据结构没有强制约定。具体的虚拟机可以自由实现它。\n"),r("strong",[a._v("总结：")])]),a._v(" "),r("ol",[r("li",[a._v("本地方法栈和虚拟机栈作用类似，本地方法栈是为虚拟机中使用到的Native方法而服务，而虚拟机栈是为执行java方法而服务")]),a._v(" "),r("li",[a._v("虚拟机规范中没有明确规定本地方法栈使用何种语言、何种数据结构实现")])]),a._v(" "),r("h3",{attrs:{id:"java堆-gc堆"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java堆-gc堆"}},[a._v("#")]),a._v(" Java堆（GC堆）")]),a._v(" "),r("p",[a._v("对于大多数应用来说，Java堆（Heap）是java虚拟机管理的最大一块内存区域，java堆是所有线程共享的一块内存区域，会在虚拟机启动时创建。\nJava堆内存的唯一目的就是：存放对象实例\n由于现在收集器都采用分代收集算法，所以java堆还可以分为新生代和老年代。\n"),r("strong",[a._v("总结：")])]),a._v(" "),r("ol",[r("li",[a._v("java堆是虚拟机管理的最大一块内存区域")]),a._v(" "),r("li",[a._v("java堆内存的目的就是存放对象实例")]),a._v(" "),r("li",[a._v("可以通过-Xmx和-Xms调整java堆内存大小")]),a._v(" "),r("li",[a._v("如果在堆中没有可用内存可以完成实例分配，并且堆无法再扩展时，会抛出OutOfMemoryError异常")])]),a._v(" "),r("h3",{attrs:{id:"方法区"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#方法区"}},[a._v("#")]),a._v(" 方法区")]),a._v(" "),r("p",[a._v("方法区和Java堆一样，是被所有线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。\n该区域的内存回收目标主要是针对常量池的回收和对类型的卸载\n"),r("strong",[a._v("总结：")])]),a._v(" "),r("ol",[r("li",[a._v("方法区和Java堆一样，是被所有线程共享的内存区域")]),a._v(" "),r("li",[a._v("存储已被虚拟机加载的类信息、常量、静态变量")]),a._v(" "),r("li",[a._v("主要回收常量池和对类型的卸载")]),a._v(" "),r("li",[a._v("当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常")])]),a._v(" "),r("h4",{attrs:{id:"运行时常量池"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#运行时常量池"}},[a._v("#")]),a._v(" 运行时常量池")]),a._v(" "),r("p",[a._v("运行时常量池是方法区的一部分，Class文件除了有类的版本、字段、方法、接口等描述信息外。还有一项重要信息就是常量池，用于存储编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中。\n"),r("strong",[a._v("总结：")])]),a._v(" "),r("ol",[r("li",[a._v("存储编译器生成的各种字面量和符号引用")]),a._v(" "),r("li",[a._v("运行时常量池属于方法区的一部分，自然受到方法区内存限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常")])])])}),[],!1,null,null,null);v.default=_.exports}}]);